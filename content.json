{"meta":{"title":"Jasondeepny Blog","subtitle":"Try to make life better!","description":"Share technology and record life!","author":"Jason","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-07-25T04:44:37.000Z","updated":"2018-07-25T04:45:15.307Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-07-25T03:35:23.000Z","updated":"2018-07-25T03:37:13.663Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-25T03:34:55.000Z","updated":"2018-07-25T03:37:39.708Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"多线程问题","slug":"多线程问题","date":"2018-07-24T16:46:31.000Z","updated":"2018-07-24T16:46:31.102Z","comments":true,"path":"2018/07/25/多线程问题/","link":"","permalink":"http://yoursite.com/2018/07/25/多线程问题/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"聊聊Nginx","slug":"聊聊Nginx","date":"2018-07-24T15:30:00.000Z","updated":"2018-07-24T15:30:53.310Z","comments":true,"path":"2018/07/24/聊聊Nginx/","link":"","permalink":"http://yoursite.com/2018/07/24/聊聊Nginx/","excerpt":"","text":"Nginx什么是Nginx？Nginx是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器 目前使用的最多的web服务器或者代理服务器，像淘宝、新浪、网易、迅雷等都在使用 为什么要用Nginx？优点： 跨平台、配置简单 非阻塞、高并发连接：处理2-3万并发连接数，官方监测能支持5万并发 内存消耗小：开启10个nginx才占150M内存 成本低廉：开源 内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。 节省宽带：支持GZIP压缩，可以添加浏览器本地缓存 稳定性高：宕机的概率非常小 master/worker结构：一个master进程，生成一个或者多个worker进程 接收用户请求是异步的：浏览器将请求发送到nginx服务器，它先将用户请求全部接收下来，再一次性发送给后端web服务器，极大减轻了web服务器的压力一边接收web服务器的返回数据，一边发送给浏览器客户端网络依赖性比较低，只要ping通就可以负载均衡可以有多台nginx服务器 事件驱动：通信机制采用epoll模型 为什么Nginx性能这么高？得益于它的事件处理机制： 异步非阻塞事件处理机制：运用了epoll模型，提供了一个队列，排队解决 Nginx是如何实现高并发的service nginx start之后，然后输入#ps -ef|grep nginx，会发现Nginx有一个master进程和若干个worker进程，这些worker进程是平等的，都是被master fork过来的。在master里面，先建立需要listen的socket（listenfd），然后再fork出多个worker进程。当用户进入nginx服务的时候，每个worker的listenfd变的可读，并且这些worker会抢一个叫accept_mutex的东西，accept_mutex是互斥的，一个worker得到了，其他的worker就歇菜了。而抢到这个accept_mutex的worker就开始“读取请求–解析请求–处理请求”，数据彻底返回客户端之后（目标网页出现在电脑屏幕上），这个事件就算彻底结束。 nginx用这个方法是底下的worker进程抢注用户的要求，同时搭配“异步非阻塞”的方式，实现高并发量。 为什么不使用多线程？因为线程创建和上下文的切换非常消耗资源，线程占用内存大，上下文切换占用cpu也很高，采用epoll模型避免了这个缺点 Nginx是如何处理一个请求的呢？ 首先，nginx在启动时，会解析配置文件，得到需要监听的端口与ip地址，然后在nginx的master进程里面,先初始化好这个监控的socket(创建socket，设置addrreuse等选项，绑定到指定的ip地址端口，再listen) 然后再fork(一个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程 )出多个子进程出来 然后子进程会竞争accept新的连接。此时，客户端就可以向nginx发起连接了。当客户端与nginx进行三次握手，与nginx建立好一个连接后,此时，某一个子进程会accept成功，得到这个建立好的连接的socket，然后创建nginx对连接的封装，即ngx_connection_t结构体,接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。 最后，nginx或客户端来主动关掉连接，到此，一个连接就寿终正寝了 正向代理一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理 正向代理总结就一句话：代理端代理的是客户端 反向代理反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求，发给内部网络上的服务器并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器 反向代理总结就一句话：代理端代理的是服务端 动态资源、静态资源分离动态资源、静态资源分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路. 动态资源、静态资源分离简单的概括是：动态文件与静态文件的分离 为什么要做动、静分离？在我们的软件开发中，有些请求是需要后台处理的（如：.jsp,.do等等），有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件）这些不需要经过后台处理的文件称为静态文件，否则动态文件。因此我们后台处理忽略静态文件。这会有人又说那我后台忽略静态文件不就完了吗当然这是可以的，但是这样后台的请求次数就明显增多了。在我们对资源的响应速度有要求的时候，我们应该使用这种动静分离的策略去解决. 动、静分离将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问这里我们将静态资源放到nginx中，动态资源转发到tomcat服务器中 负载均衡负载均衡即是代理服务器将接收的请求均衡的分发到各服务器中 负载均衡主要解决网络拥塞问题，提高服务器响应速度，服务就近提供，达到更好的访问质量，减少后台服务器大并发压力 关于正向代理和反向代理的知识可参见: 代理概述","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"spring 使用中遇到的错误小集","slug":"spring 使用中遇到的错误小集","date":"2018-07-21T14:09:04.000Z","updated":"2018-07-23T14:35:43.711Z","comments":true,"path":"2018/07/21/spring 使用中遇到的错误小集/","link":"","permalink":"http://yoursite.com/2018/07/21/spring 使用中遇到的错误小集/","excerpt":"","text":"spring Junit单元测试事务管理报错：java.lang.IllegalStateException: Failed to load ApplicationContext解决办法错误信息如下： Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'userservice' defined in class path resource [applicationContext.xml]: BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.aop.aspectj.AspectJPointcutAdvisor#0': Cannot create inner bean '(inner bean)#56a6d5a6' of type [org.springframework.aop.aspectj.AspectJMethodBeforeAdvice] while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#56a6d5a6': Cannot create inner bean '(inner bean)#3c9d0b9d' of type [org.springframework.aop.config.MethodLocatingFactoryBean] while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#3c9d0b9d': Initialization of bean failed; nested exception is java.lang.IllegalArgumentException: Unable to locate method [before] on bean [userservice] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.aop.aspectj.AspectJPointcutAdvisor#0': Cannot create inner bean '(inner bean)#56a6d5a6' of type [org.springframework.aop.aspectj.AspectJMethodBeforeAdvice] while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#56a6d5a6': Cannot create inner bean '(inner bean)#3c9d0b9d' of type [org.springframework.aop.config.MethodLocatingFactoryBean] while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#3c9d0b9d': Initialization of bean failed; nested exception is java.lang.IllegalArgumentException: Unable to locate method [before] on bean [userservice] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#56a6d5a6': Cannot create inner bean '(inner bean)#3c9d0b9d' of type [org.springframework.aop.config.MethodLocatingFactoryBean] while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#3c9d0b9d': Initialization of bean failed; nested exception is java.lang.IllegalArgumentException: Unable to locate method [before] on bean [userservice] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#3c9d0b9d': Initialization of bean failed; nested exception is java.lang.IllegalArgumentException: Unable to locate method [before] on bean [userservice] Caused by: java.lang.IllegalArgumentException: Unable to locate method [before] on bean [userservice] 由于我的粗心在配置切点的时候少打了一个空格就出事情了,建议各位在配置的时候能动态配置就动态配置,避免出错下面是我的错误就修改图如下: 错误代码: 纠正后: Spring 配置异常解决办法之Referenced file contains errors(心在滴血!搞了快一个多小时) Referenced file contains errors (http://www.springframework.org/schema/aop/spring-beans-4.2.xsd). For more information, right click on themessage in the Problems View and select “Show Details…” 前面好几个配置文件都没事情,到配置aop就出事情了 第一种解决方案 这是由于缓冲造成的,里面有相关的配置和当前定义冲突,解决办法是打开Preferences -&gt; General -&gt; Network Connections -&gt; Cache,然后删除里面的缓存信息. 第二种方案 测试类中ContextConfiguration注解中属性classpath地址配置错误，修改路径即可 第三种方案 Window–Preferences–搜索“Validation”，去掉XML Validator 和 XSL Validator 等文件类型的验证信息(包括Manual和Build)，如下图所示: 最终用的是第三种方案搞定! 最终用的是第三种方案搞定! Junit 少有的错误: java.lang.Exception: No tests found matching [{ExactMatcher:fDisplayName=testDemo], {ExactMatcher:fDisplayName=testDemo(com.itheima.service.MyProxy)],{LeadingIdentifierMatcher:fClassName=com.itheima.service.MyProxy,fLeadingIdentifier=testDemo]]from org.junit.internal.requests.ClassRequest@2d38eb89 总结：使用Junit单元测试时，要注意以下几个地方： 在测试方法上要有@Test注解 测试方法不能用static静态修饰 测试方法不能有返回值 测试方法不能有参数 如果测试类继承基础测试类，那么这个类中的所有测试方法都要符合以上四条规定.","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"数据库之Oracle篇详解(二)","slug":"数据库之Oracle篇详解-二","date":"2018-07-17T13:07:27.000Z","updated":"2018-07-17T13:08:56.455Z","comments":true,"path":"2018/07/17/数据库之Oracle篇详解-二/","link":"","permalink":"http://yoursite.com/2018/07/17/数据库之Oracle篇详解-二/","excerpt":"","text":"01.单表查询-简单条件和去重.avi查询语句的执行顺序当一条查询语句中包含所有的子句，执行顺序依下列子句次序：FROM 子句：执行顺序为从后往前、从右到左。数据量较少的表尽量放在后面。WHERE子句：执行顺序为自下而上、从右到左。将能过滤掉最大数量记录的条件写在WHERE 子句的最右。GROUP BY：执行顺序从左往右分组，最好在GROUP BY前使用WHERE将不需要的记录在GROUP BY之前过滤掉。HAVING 子句：消耗资源。尽量避免使用，HAVING 会在检索出所有记录之后才对结果集进行过滤，需要排序等操作。SELECT子句：少用*号，尽量取字段名称。ORACLE 在解析的过程中, 通过查询数据字典将*号依次转换成所有的列名, 消耗时间。ORDER BY子句：执行顺序为从左到右排序，消耗资源 SQL语句的书写顺序select…from…where…group…having…order…limit…; 简单查询关键字distinct去重复,如果是多个字段必须所有字段值一致才可去重复andorbetween… and…is not nullis nulllikeinselect * from t_aaa where name like &#39;%\\%%&#39; escape &#39;\\&#39;; 02.单表查询-排序和基于伪列查询.avi排序：order by 默认升序 降序使用desc 去掉null之后再排序select * from emp where sal is not null order by sal desc ;Oracle中的两个伪列ROWID ：代表的是一个物理地址，定位记录存储的区块，磁盘的扇区与磁道。ROWNUM：查询结果的序号, rownum&lt;=5 rownum&gt;=5 不允许 03.单表查询-聚合统计.avi聚合函数count/sum/avg/max/minhaving关键字group by …..having…having对分组之后的结果再进行条件查询select 后必须写分组条件或者聚合函数过滤空值字段select avg(nvl(comm,0)) from emp; 04.内连接.avi隐式内连接 select * from A,B where A.ID=B.ID;显示内连接 select * from A inner join B on A.ID=B.ID 查询的结果是两个表匹配数据显示(交集) 05.外连接.avi左外连接标准sql写法select * from A left join B on A.ID=B.ID oracle写法select * from A,B where A.ID=B.ID(+)右外连接标准sql写法select * from A right join B on A.ID=B.IDoracle写法select * from A,B where A.ID(+)=B.ID 如果+号在等号的右边则是左外连接,如果+号在等号的左边则是右外连接 full join :查询出两个表中的所有记录（不是求笛卡尔积）select * from emp full join dept on emp.deptno=dept.deptno; 06.where子句中的子查询.aviwhere子查询单行子查询：子查询返回一个值=,&gt;,&gt;=,&lt;, &lt;=, &lt;&gt;多行子查询：返回多个值in , not in, any, all将子查询的结果看成是一个表再进行查询select * from dept where deptno not in (10,20,30,null);select * from dept where deptno not in (select distinct deptno from emp where deptno is not null); 07.from子句的子查询.avifrom子查询为多行子查询select * from (select o.id 业主编号,o.name 业主名称,ot.name 业主类型 from T OWNERS o T OWNERTYPE ot where o.ownertypeid=ot.id) where 业主类型=&#39;居民&#39; 08.select子句子查询.aviselect 子句的子查询必须为单行子查询select id,name,(select name from t_address where id=addressid) addressname from t_owners 09.分页查询.avirownum进行分页select * from (select rownum r,t.* from (select * from T_ACCOUNT order by usenum desc) t where rownum&lt;=20 ) where r&gt;10 select * from ( select rownum r,e.* from (select * from emp order by sal) e) ee where ee.r&gt;4 and ee.r&lt;=8; rownum 生成时机：在查询扫描到记录之后生成序号，再排序rownum 是在查询语句扫描每条记录时产生的，所以不能使用“大于” 符号，只能使用“小于”或“小于等于” ，只用“等于”也不行 10.字符函数.avi函数不能通用length() 字符串长度substr(字符串，开始位置，长度) 位置从1开始concat(‘’,’’) 连接Oracle的字符串连接符：|| 11.数值函数.aviround() 四舍五入floor() 小于或等于 value 的最大整数ceil() 大于或等于 value 的最小整数trunc(,-2) 数字截取mod() 取模 12.日期函数.aviadd_months(,) 添加月份select add months(sysdate,2) from duallast_day() 获得当月的最后一天select last day(sysdate) from dualtrunc() 截取日期select TRUNC(sysdate,&#39;yyyy&#39;) from dualselect TRUNC(sysdate,&#39;mm&#39;) from dual日期+数字=日期日期-数字=日期日期-日期=天数 13.转换函数.avi数字转字符串select TO_CHAR(1024) from dual将日期转字符串select TO_CHAR(sysdate,&#39;yyyy-mm-dd&#39;) from dual将字符串转日期select TO_DATE(&#39;2017-01-01&#39;,&#39;yyyy-mm-dd&#39;) from dual select * from emp where to_char(hiredate,&#39;yyyy-mm-dd&#39;)=&#39;1981/02/22&#39;; 数字转字符串 ||字符串转数字 +0 14.其它函数.avinvl() 空值处理select ename,nvl(sal,0)+nvl(comm,0) from emp;nvl2(，，) 空值处理select PRICE,MINNUM,NVL2(MAXNUM,to char(MAXNUM) , &#39;不限&#39;) from T PRICETABLE where OWNERTYPEID=1 decode条件取值decode(条件,值 1,翻译值 1,值 2,翻译值 2,...值 n,翻译值 n,缺省值)decode(100,1,2,3,4,100,5,0)case when then 语句 12345678910111213select name ,(case ownertypeid when 1 then '居民' when 2 then '行政事业单位' when 3 then '商业' else '其它' end) from T OWNERS--另一种写法select name,(case when ownertypeid= 1 then '居民' when ownertypeid= 2 then '行政事业' when ownertypeid= 3 then '商业' end)from T OWNERS 15.行列转换.avi1234567891011121314select (select name from T AREA where id=areaid) 区域,sum( case when month='01' then money else 0 end) 一月,sum( case when month='02' then money else 0 end) 二月,sum( case when month='03' then money else 0 end) 三月,sum( case when month='04' then money else 0 end) 四月,sum( case when month='05' then money else 0 end) 五月,sum( case when month='06' then money else 0 end) 六月,sum( case when month='07' then money else 0 end) 七月,sum( case when month='08' then money else 0 end) 八月,sum( case when month='09' then money else 0 end) 九月,sum( case when month='10' then money else 0 end) 十月,sum( case when month='11' then money else 0 end) 十一月,sum( case when month='12' then money else 0 end) 十二月from T ACCOUNT where year='2012' group by areaid 16.分析函数.avi 作用：排名，排序rank() over(排序字段) 相同的值排名相同，排名跳跃dense_rank() over(排序字段) 相同的值排名相同，排名连续row_number() over(排序字段) 返回连续的排名，无论值是否相等,可实现分页select * from ( select row_number() over(order by sal desc) row,t.* from emp t ) where row &gt;=10 and row&lt;20 17.集合运算.aviUNION ALL(并集)，返回各个查询的所有记录，包括重复记录。UNION(并集)，返回各个查询的所有记录，不包括重复记录。INTERSECT(交集)，返回两个查询共有的记录。MINUS(差集)，返回第一个查询检索出的记录减去第二个查询检索出的记录之后剩余的记录,也可以做分页。 运算的两边查询必须一致 总结 单表查询单表查询关键字and ,or ,in ,not in,between and ,order by ,group by having, distinct,is null,is not null… 多表连接查询内连接：隐式：select * from a,b where a.id=b.id;显式：select * from a join b on a.id=b.id;外连接左外连接：select * from a left join b on a.id=b.id;右外连接: select * from a right join b on a.id=b.id;全外连接: select * from a full join b on a.id=b.id; 子查询sel嵌套where子查询select * from emp where sal &gt;(select sal from emp where ename=’’);from子查询select * from (select o.id 业主编号,o.name 业主名称,ot.name 业主类型 from T OWNERS o T OWNERTYPE ot where o.ownertypeid=ot.id) where 业主类型=&#39;居民&#39; 分页select * from (select rownum r,e.* from (select * from emp order by sal) e) ee where ee.r&gt;=4 and ee.r &lt;=8; 函数length()/substr()/floor()/round()/ceil()/trunc()/add_months()/last_day()/to_char()/to_date()/nvl()/decode()----case when then 行列转换 集合运算：union 并集去重复union all 并集不去重复minus 差集intersect 交集","categories":[],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"如何避免自己写的代码成为别人眼中的一坨屎!","slug":"如何避免自己写的代码成为别人眼中的一坨屎","date":"2018-07-16T10:17:52.000Z","updated":"2018-07-16T10:36:30.892Z","comments":true,"path":"2018/07/16/如何避免自己写的代码成为别人眼中的一坨屎/","link":"","permalink":"http://yoursite.com/2018/07/16/如何避免自己写的代码成为别人眼中的一坨屎/","excerpt":"Any fool can write code that a computer can understand. Good programmers write code that humans can understand. 普通的工程师堆砌代码，优秀的工程师优雅代码，卓越的工程师简化代码。","text":"Any fool can write code that a computer can understand. Good programmers write code that humans can understand. 普通的工程师堆砌代码，优秀的工程师优雅代码，卓越的工程师简化代码。 来源：云栖社区 | 作者：竹涧 | 原文地址见文末 &nbsp;&nbsp;&nbsp;普通的工程师堆砌代码，优秀的工程师优雅代码，卓越的工程师简化代码。如何写出优雅整洁易懂的代码是一门学问，也是软件工程实践里重要的一环。笔者推荐三本经典的书籍《代码整洁之道 》、《编写可读代码的艺术》、《重构:改善既有代码的设计》，下文重点将从注释、命名、方法、异常、单元测试等多个方面总结了一些代码整洁最佳实践，大部分是笔者总结于以上三本书中的精华，也有部分是笔者工程实践的总结。篇幅有限，本文将总结性给出一些实践建议，后续会有文章来给出一些代码整洁之道的事例。 一、注释不要给不好的名字加注释，一个好的名字比好的注释更重要； 不要“拐杖注释”，好代码 &gt; 坏代码 + 好注释； 在文件/类级别使用全局注释来解释所有部分如何工作； 一定要给常量加注释； 团队统一定义标记： TODO 待处理的问题； FIXME 已知有问题的代码； HACK 不得不采用的粗糙的解决方案； 在注释中用精心挑选的输入输出例子进行说明； 注释应该声明代码的高层次意图，而非明显的细节； 不要在代码中加入代码的著作信息，git可以干的事情不要交给代码； 源代码中的html注释是一种厌物, 增加阅读难度； 注释一定要描述离它最近的代码； 注释一定要与代码对应； 公共api需要添加注释，其它代码谨慎使用注释； 典型的烂注释： 不恰当的信息； 废弃的注释； 冗余注释； 糟糕的注释； 注释掉的代码； 唯一真正好的注释是你想办法不去写的注释： 不要有循规式注释，比如setter/getter注释； 不要添加日志式注释，比如修改时间等信息（git可以做的事情）； 注释一定是表达代码之外的东西，代码可以包含的内容，注释中一定不要出现； 如果有必要注释，请注释意图（why），而不要去注释实现（how)，大家都会看代码； 适当添加警示注释； 二、命名尽可能使用标准命名方法，比如设计模式，通用学术名词等； 命名要找更有表现力的词： 使用更专业的词，比如不用get而使用fetch或者download； 避免空泛的名字，像tmp； 使用具体的名字来细致的描述事物； 给变量名带上重要的细节，比如加上单位ms等； 为作用域大的名字采用更长的名字，作用域小的使用短名字； 变量类型为布尔值表达加上is，has，can，should这样的词会更明确； 变量名称长短应该与其作用域对应； 别害怕长名称，长而具有描述性的名称比短而令人费解的名称好； 函数名称应该说明副作用，名称应该表达函数，变量或类的一切信息，请不要掩盖副作用，比如CreateAndReturnXXX； 三、方法函数不应该有100行那么长，20行封顶最好： if else while等控制语句其中代码块应该只有一行，也就是一个函数调用语句； 函数的锁进层次不应该多于两层； 一个函数只做一件事，一个函数不应该能抽象出另外一个函数； 某个公共函数调用的私有函数紧随其后； 最理想的参数是零参数，最长不要超过三个入参，尽量不要输出参数： 如果函数传入三个及以上参数最好将其抽象为类； 标识参数十分丑陋，向函数传入布尔值用于区分不同业务的做法很丑陋，应该拆分为多个函数； 别返回null值，抛出异常或者返回特殊对象，尽量避免NPE； 别传入null值； 四、异常与错误抽离try catch包含的代码块，其中代码块抽象为一个函数； 抛出的每个异常，都应当提供足够的环境说明，已便判断错误的来源与处所； 不要将系统错误归咎于偶然事件； 五、并发分离并发相关代码与其它代码； 严格限制对可能被共享的数据的访问； 避免使用一个共享对象的多个同步方法； 保持同步区域微小，尽可能少设计临界区； 六、单元测试不要怕单元测试的方法名字太长或者繁琐，测试函数的名称就像注释； 不要追求太高的测试覆盖率，测试代码前面90%通常比后面10%花的时间少； 使用最简单的并且能够完整运用代码的测试输入；； 给测试函数取一个完整性的描述性名字，比如 Test _； 测试代码与生产代码一样重要； 如果测试代码不能保证整洁，你就会很快失去他们； 每个测试一个断言，单个测试中断言数量应该最小化也就是一个断言； FIRST原则： 快速 Fast； 独立 Independent 测试应该相互独立； 可重复 Repeatable 测试应当在任何环境中重复通过； 自足验证 Self-Validating 测试应该有布尔值输出； 及时 Timely 最好的方式是TDD； 七、代码结构代码行长度控制在100-120个字符； 可能用大多数为200行，最长500行的单个文件构造出色的系统； 关系密切的代码应该相互靠近： 变量声明应该靠近其使用位置； 若某个函数调用了另外一个，应该把他们放在一起，而且调用者应该放在被调用者上面； 自上向下展示函数调用依赖顺序； 应该把解释条件意图的函数抽离出来，尽可能将条件表达为肯定形式； 不要继承常量，比如接口中定义常量，不要使用继承欺骗编程语言的作用范围规则； 模块不应了解它所操作对象的内部情况； DTO（Data Transfer Objects）是一个只有公共变量没有函数的类； 对象暴露行为，隐藏数据； 不要使用“尤达表示法” 如 if(null == obj)，现代编译器对if(obj = null)这样的代码会给出警告； 一般情况使用if else，简单语句使用三目运算符； 通常来讲提早返回可以减少嵌套并让代码整洁； 八、设计类应该足够短小： 类应该满足单一权责原则（SRP），类和模块只有一个修改理由； 类应该只有少量的实体变量； 类应该遵循依赖倒置原则 DIP（Dependency Inversion Principle），类应该依赖于抽象而不是依赖于具体细节； 类中的方法越少越好，函数知道的变量越少越好，类拥有的实体变量越少越好； 通过减少变量的数量和让他们尽量“轻量级”来让代码更有可读性： 减少变量； 缩小变量的作用域； 只写一次的变量更好，如常量； 最好读的代码就是没有代码： 从项目中消除不必要的功能，不要过度设计； 从新考虑需求，解决版本最简单的问题，只要能完成工作就行； 经常性地通读标准库的整个API，保持对他们的熟悉程度； 简单设计： 运行所有测试； 不可重复； 表达了程序员的意图； 尽可能减少类和方法的数量； 以上规则按重要程度排列； 无论是设计系统或者单独模块，别忘了使用大概可工作的最简单方案； 整洁的代码只提供一种而非多种做一件事的途径，他只有尽量少的依赖。明确定义并提供尽量少的API； 减少重复代码，提高表达力，提早构建，简单抽象； 九、小结作为代码整洁之道系列的第一篇，本文从注释、命名、方法，单元测试，并发等视角简单给出了一些最佳实践，下文我们会展开来从每个方面介绍更多的实践事例。相信每一个优秀的工程师都有一颗追求卓越代码的心，在代码整洁工程实践上你有哪些好的建议？数百人协作开发的代码如何保证代码整洁一致性？欢迎大家来讨论。 原文地址：https://yq.aliyun.com/articles/598076?utm_content=m_51055","categories":[],"tags":[{"name":"职业之路","slug":"职业之路","permalink":"http://yoursite.com/tags/职业之路/"}]},{"title":"浅析ActionContext与ServletActionContext的区别","slug":"浅析ActionContext与ServletActionContext的区别","date":"2018-07-12T05:34:20.000Z","updated":"2018-07-16T10:36:23.733Z","comments":true,"path":"2018/07/12/浅析ActionContext与ServletActionContext的区别/","link":"","permalink":"http://yoursite.com/2018/07/12/浅析ActionContext与ServletActionContext的区别/","excerpt":"&nbsp;&nbsp;&nbsp;在学习Struts的过程中,很多人对于ActionContext与ServletActionContext两个对象之间的关系不是很清楚,这两个对象尤其是ActionContext对于Struts的学习至关重要,所以接下来我对二者来做一个较为详细的分析.","text":"&nbsp;&nbsp;&nbsp;在学习Struts的过程中,很多人对于ActionContext与ServletActionContext两个对象之间的关系不是很清楚,这两个对象尤其是ActionContext对于Struts的学习至关重要,所以接下来我对二者来做一个较为详细的分析. ActionContext&ensp;&ensp;&ensp;我们知道，ActionContext是Action执行时的上下文，里面存放着Action在执行时需要用到的对象，也称之为广义值栈。Struts2在每次执行Action之前都会创建新的ActionContext，在同一个线程里ActionContext里面的属性是唯一的，这样Action就可以在多线程中使用。 1.1 ActionContext的线程安全性&emsp;&emsp;那么Struts2是如何保证ActionContext的线程安全性呢？看看ActionContext对象的代码，示例如下： 1234public class ActionContext implements Serializable &#123; static ThreadLocal actionContext = new ThreadLocal(); …… &#125; 1.2 访问的是Map&emsp;&emsp;回顾前面在使用ActionContext来访问Session中数据的程序，你会发现，其实在程序里面访问的是一个Map，而非HttpSession对象，这是为什么呢？ &emsp;&emsp;原来，Struts2框架将与Web相关的很多对象重新进行了包装，比如将HttpSession对象重新包装成了一个Map对象，里面存放着Session中的数据，提供这个Map给Action使用，而不用Action直接和底层的HttpSession打交道。也正是因为框架的包装，让Action可以完全的和Web层解耦。但是要注意一点，ActionContext不能在普通的Java应用程序中使用。我们知道Action和Servlet API是解耦的，因此可以在Java应用程序中调用Action的execute方法来进行测试。但是如果使用了ActionContext来获取session数据，那么就不能这样运行了。因为ActionContext包装的都是Web的数据，在Java应用程序中运行的时候，没有Web的环境和响应的数据，因而会抛出空指针的异常。访问其它的Web对象的值也是与此类似的，你通过ActionContext去访问的都是包装后的Map。 1.3 使用SessionAware接口&emsp;&emsp;Struts2还提供另外一种简单的方式，使用SessionAware接口来访问存储于ActionContext中的数据，该接口通过使用IoC/DI来为Action注入Session Map，就可以在程序里面直接使用这个Map来操作数据了。 &emsp;&emsp;（1）在Action中不再需要访问ActionContext了，取而代之，Action实现SessionAware接口，该接口告知Struts2在Action执行之前要设置Session Map，是通过servletConfig 拦截器来实现的，这个拦截器在defaultStack里面就有。示例代码如下： 1234567891011public class OgnlAction extends ActionSupport implements SessionAware&#123; private Map&lt;String, Object&gt; session; public void setSession(Map&lt;String, Object&gt; session) &#123; this.session = session; &#125; public String execute()&#123; session.put(\"sessionTestKey\", \"测试SessionAware\"); return this.SUCCESS; &#125; &#125; 在上面的代码中： Action类实现SessionAware接口 这个接口要求Action类实现一个方法setSession(Map&lt;String, Object&gt; session)，通过这个方法注入Session的数据 在execute方法中，通过这个私有属性就可以操作会话中的数据，注意一点，这个Map中的值也是与HttpSession联动的。 &emsp;&emsp;（2）我们可以再前台获取session中的属性，以便看出Action操作session后的效果，示例如下：1234&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt; 会话中的值：&lt;s:property value=\"#session['sessionTestKey']\"/&gt; &lt;br&gt; 通过Servlet的Api获取会话中的值：&lt;%=session.getAttribute(\"sessionTestKey\") %&gt; &emsp;&emsp;为了能够在普通的Java应用中运行并测试Action，推荐大家使用SessionAware的方式来访问HttpSession。因为这样一来，在通过main方法运行或测试的时候，可以直接调用setSession方法，传入模拟的会话数据，就不会出现execute方法中抛出空指针的异常了。因此，推荐大家使用SessionAware的方式来访问HttpSession。 1.4 使用其它包装接口&emsp;&emsp;跟SessionAware类似，你可以使用RequestAware来获取包装请求对象的attribute中的值的Map；使用ApplicationAware来获取包装ServletContext对象的attribute中的值的Map；使用ParameterAware来获取包装请求对象的参数中的值的Map，等等，这里只罗列这几个常见和常用的，还有更多的请参见Struts2的API文档。 ServletActionContext&emsp;&emsp;在实际应用开发中，光是获取数据就够了吗？答案显然是否定的，有些时候，根据功能需要，在Action中必须要能获取到Servlet相关的API，比如要操作Cookie。这个时候，就需要用ServletActionContext了。 2.1 ServletActionContext概述&emsp;&emsp;这个类直接继承了ActionContext，当然也继承了它父类的很多功能，比如：对OgnlValueStack、Action名字等的访问。更重要的是，它还提供了直接访问Servlet的相关对象的功能，它可以取得的对象有： -HttpServletRequest：请求对象-HttpServletResponse：响应对象-ServletContext：Servlet上下文信息-PageContext：Http页面上下文 2.2 基本使用&emsp;&emsp;这里要注意的是HttpSession对象的获取，是在取得HttpRequest对象过后，通过HttpRequest对象来获取会话对象。当然，取得相应的对象后，就直接使用这些对象的方法来进行开发，这里就不去赘述了。 2.3 通过IoC/DI的方式来获取相应的Servlet对象&emsp;&emsp;还可以通过IoC/DI的方式来获取相应的Servlet对象，对应关系是： ServletRequestAware：通过这个接口来获取HttpServletRequest对象 ServletResponseAware：通过这个接口来获取HttpServletResponse对象&emsp;&emsp;用ServletRequestAware来示例一下。 &emsp;&emsp;（1）修改Action，让其实现ServletRequestAware接口，示例代码如下：123456789101112public class OgnlAction extends ActionSupport implements ServletRequestAware&#123; private HttpServletRequest request = null; public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125; public String execute()&#123; request.setAttribute(\"request\", \"Request的属性值\"); request.getSession().setAttribute(\"sessionTestKey\", \"测试SessionAware\"); return this.SUCCESS; &#125; &#125; &emsp;&emsp;（2）对应的结果页面也需要稍作修改，要把Action中设置的值显示出来，示例如下： &lt;%@ taglib prefix=”s” uri=”/struts-tags”%&gt;Request的属性值：&lt;s:property value=”#request[‘request’]”/&gt;会话的属性值：&lt;s:property value=”#session[‘sessionTestKey’]”/&gt; 3 ActionContext和ServletActionContext&emsp;&emsp;根据前面的讲述，你会发现，ActionContext和ServletActionContext有着一些重复的功能，都能够获取到Web对象的数据，但是又有些不同。通常情况下，可以这么认为：ActionContext主要负责值的操作；ServletActionContext主要负责获取Servlet对象。那么在Action中，该如何去抉择呢？建议的原则是：-优先使用ActionContext-只有ActionContext不能满足功能要求的时候，才使用ServletActionContext &emsp;&emsp;总之，要尽量让Action与Web无关，这对于Action的测试和复用都是极其有好处的。另外还有一点需要注意：在使用ActionContext时，不要在Action的构造函数里使用ActionContext.getContext()，因为这个时候ActionContext里的一些值也许还没有设置，这时通过ActionContext取得的值也许是null。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"redis-常见问题及其解决方案","slug":"redis-常见问题及其解决方案","date":"2018-07-11T00:38:06.000Z","updated":"2018-07-16T10:38:13.512Z","comments":true,"path":"2018/07/11/redis-常见问题及其解决方案/","link":"","permalink":"http://yoursite.com/2018/07/11/redis-常见问题及其解决方案/","excerpt":"redis 客户端 不能存储问题 (error) MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.","text":"redis 客户端 不能存储问题 (error) MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error. – 原因： 强制关闭Redis快照导致不能持久化。 解决方案： 运行config set stop-writes-on-bgsave-error no命令后，关闭配置项stop-writes-on-bgsave-error解决该问题。 root@ubuntu:/usr/local/redis/bin# ./redis-cli 127.0.0.1:6379&gt; config set stop-writes-on-bgsave-error no OK 127.0.0.1:6379&gt; lpush myColour &quot;red&quot; (integer) 1 关于java端连不上redis pool的问题（ 逐一排除 ） 确认java程序无误 可能是redis配置文件中端口的限制 进入redis.conf文件 默认配置是本地IP 所以直接将里面的bind 127.0.0.1注释掉 防火墙问题 首先是虚拟机防火墙问题命令窗口将redis 6379 端口放开 命令：`/sbin/iptables -I INPUT -p tcp –dport 6379 -j ACCEPT/etc/rc.d/init.d/iptables save` 如果仍然不能连接，则断开防火墙（有风险） 永久性生效，重启后不会复原开启： chkconfig iptables on关闭： chkconfig iptables off2.即时生效，重启后复原开启： service iptables start关闭： service iptables stop 考虑redis版本或是java 程序的两个jar包 的不兼容的问题，更换匹配的jar包 注意：在更换redis版本前 首先要关闭客户端，执行命令./redis-cli shutdown或者干掉线程，命令ps -ef|grep redis进行查看线程，执行命令kill -9 线程号 其次要清空虚拟机中的所有redis文件再重新安装 经过这几个步骤基本可以解决问题啦~~~","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"数据库之Oracle篇详解(一)","slug":"数据库之Oracle篇详解-一","date":"2018-07-10T16:14:00.000Z","updated":"2018-07-16T10:37:49.602Z","comments":true,"path":"2018/07/11/数据库之Oracle篇详解-一/","link":"","permalink":"http://yoursite.com/2018/07/11/数据库之Oracle篇详解-一/","excerpt":"01.什么是ORACLE.aviOracle 数据库ORACLE 数据库的特点 支持多用户、大事务量的事务处理 数据安全性和完整性控制 支持分布式数据处理 可移植性","text":"01.什么是ORACLE.aviOracle 数据库ORACLE 数据库的特点 支持多用户、大事务量的事务处理 数据安全性和完整性控制 支持分布式数据处理 可移植性 02.挂载window2003.avi03.网络配置.avi使用ping命令测试本机到虚拟机的网络是否连通ping 192.168.246.110 04.ORACLE安装及体系结构讲解.aviORACLE 体系结构 几个概念 数据库实例 orcl 表空间：管理dbf文件 用户 表 几个关系一个实例对应多个表空间一个表空间对应多个用户一个表空间对应多个数据文件(.dbf/.ora)一个用户对应多个表一个表中的数据存储在多个数据文件中 05.远程连接ORACLE.avi 使用工具instantclient_12_1 06.可视化工具安装与配置.avi 配置PL/SQL developer 拷贝tnsnames.ora 修改IP 配置环境变量（tnsnames.ora路径，中文配置） 设置中文编码查看服务器端编码 select userenv(&#39;language&#39;) from dual结果为:AMERICAN_AMERICA.ZHS16GBK计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;新建设置变量名:NLS_LANG变量值:查到的值AMERICAN_AMERICA.ZHS16GBK 注意事项：安装目录不能有中文和空格，否则连接不上 07.需求分析与表结构.avi 08.创建表空间.avi12345create tablespace waterbossdatafile 'c:\\waterboss.dbf'size 100mautoextend onnext 10m 09.创建用户与用户赋权.avi123create user wateruseridentified by itcastdefault tablespace waterboss 给用户设置权限 1grant dba to wateruser 10.表的创建修改与删除.aviSQL可分为: 数据定义语言（DDL） : Data Definition Language用于建立、修改、删除数据库对象，包括创建语句(CREATE)、修改语句(ALTER)、删除语句(DROP)，比如使用CREATE TABLE创建表，使用ALTER TABLE修改表，使用DROPTABLE删除表等动作。==这类语言不需要事务的参与，自动提交。== 数据操纵语言（DML） : Data Manipulation Language用于改变数据库数据，包括INSERT、UPDATE、DELETE三条语句。其中，INSERT语句用于将数据插入到数据库中，UPDATE语句用于更新数据库中已存在的数据，DELETE用于删除数据库中已存在的数据。==DML语言和事务是相关的，执行完DML操作后必须经过事务控制语句提交后才真正的将改变应用到数据库中。== 事务控制语言（TCL）：Transaction Control Language)用来维护数据一致性的语句，包括提交(COMMIT)、回滚(ROLLBACK)、保存点(SAVEPOINT)三条语句，其中COMMIT用来确认已经进行的数据库改变， ROLLBACK语句用来取消已经进行的数据库改变，当执行DML操作后(也就是上面说的增加、修改、删除等动作)，可以使用COMMIT语句来确认这种改变，或者使用ROLLBACK取消这种改变。SAVEPOINT语句用来设置保存点，使当前的事务可以回退到指定的保存点，便于取消部分改变。 数据查询语言（DQL）：Data Query Language用来查询所需要的数据。使用最广泛，语法灵活复杂。 数据控制语言（DCL） : Data Control Language用于执行权限的授予和收回操作、创建用户等，包括授予(GRANT)语句，收回(REVOKE)语句，CREATE USER语句，其中GRANT用于给用户或角色授予权限， REVOKE用于收回用户或角色已有的权限。==DCL语句也不需要事务的参与，是自动提交的。== 数据类型NUMBER表示数字类型，经常被定义成NUMBER（7，2）形式，其中： P表示数字的总位数 S表示小数点后面的位数CHAR表示固定长度的字符类型，经常被定义成CHAR（5）形式, N表示占用的字节数，N的最大取值是2000VARCHAR2表示变长的字符类型，定义格式是VARCHAR2（10）, N表示最多可占用的字节数，最大长度是4000字节 123456789101112131415161718192021--表的创建CREATE TABLE 表名称( 字段名 类型(长度) primary key, 字段名 类型(长度), .......);--表的修改--增加字段ALTER TABLE 表名称 ADD(列名 1 类型 [DEFAULT 默认值]，列名 1 类型[DEFAULT 默认值]...)--修改字段ALTER TABLE 表名称 MODIFY(列名 1 类型 [DEFAULT 默认值]，列名 1 类型[DEFAULT 默认值]...)--修改字段名ALTER TABLE 表名称 RENAME COLUMN 原列名 TO 新列名--删除一个字段ALTER TABLE 表名称 DROP COLUMN 列名--删除多个字段ALTER TABLE 表名称 DROP (列名 1,列名 2...)--表的删除DROP TABLE 表名称 11.数据增删改.avi123456--插入数据INSERT INTO 表名[(列名 1，列名 2，...)]VALUES(值 1，值 2，...)--修改数据UPDATE 表名 SET 列名 1=值 1，列名 2=值 2，....WHERE 修改条件--删除数据DELETE FROM 表名 WHERE 删除条件 truncate 与delete区别 delete 删除的数据可以 rollback delete 删除可能产生碎片，并且不释放空间 truncate 是先摧毁表结构，再重构表结构 DML（insert update,delete）需要提交事务(update/insert/delete)DDL（create drop alter tuncate）不要提交事务（create/drop/alter/truncate） 12.JDBC连接Oracle-搭建开发环境和编写工具类.avi123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.itcast.waterboss.dao;import java.sql.SQLException;/*** 基本数据访问类* @author Administrator**/public class BaseDao &#123;//加载驱动static&#123; try &#123; Class.forName(\"oracle.jdbc.driver.OracleDriver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;/*** 获取数据库连接* @return* @throws SQLException*/public static java.sql.Connection getConnection() throws SQLException&#123; return java.sql.DriverManager.getConnection(\"jdbc:oracle:thin:@192.168.80.10:1521:orcl\",\"wateruser\", \"itcast\");&#125;/*** 关闭资源* @param rs* @param stmt* @param conn*/public static void closeAll(java.sql.ResultSet rs, java.sql.Statement stmt,java.sql.Connection conn)&#123; //关闭结果集 if(rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //关闭执行对象 if(stmt!=null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //关闭执行对象 if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 13.JDBC连接Oracle-数据的增删改操作.avi123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package cn.itcast.waterboss.dao;import java.sql.SQLException;import cn.itcast.waterboss.entity.Owners;/*** 业主数据访问类* @author Administrator**/public class OwnersDao &#123; /** * 新增业主 * @param owners */ public static void add(Owners owners)&#123; java.sql.Connection conn=null; java.sql.PreparedStatement stmt=null; try &#123; conn=BaseDao.getConnection(); stmt=conn.prepareStatement(\"insert into T_OWNERS values(?,?,?,?,?,?,?)\"); stmt.setLong(1, owners.getId()); stmt.setString(2, owners.getName()); stmt.setLong(3, owners.getAddressid()); stmt.setString(4, owners.getHousenumber()); stmt.setString(5, owners.getWatermeter()); stmt.setDate(6, new java.sql.Date(owners.getAdddate().getTime())); stmt.setLong(7, owners.getOwnertypeid()); stmt.execute(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; BaseDao.closeAll(null, stmt, conn); &#125; &#125; /** * 修改业主 * @param owners */ public static void update(Owners owners)&#123; java.sql.Connection conn=null; java.sql.PreparedStatement stmt=null; try &#123; conn=BaseDao.getConnection(); stmt=conn.prepareStatement(\"update T_OWNERS set name=?,addressid=?,housenumber=?,\" + \"watermeter=?,adddate=?, ownertypeid=? where id=?\"); stmt.setString(1, owners.getName()); stmt.setLong(2, owners.getAddressid()); stmt.setString(3, owners.getHousenumber()); stmt.setString(4, owners.getWatermeter()); stmt.setDate(5, new java.sql.Date(owners.getAdddate().getTime())); stmt.setLong(6, owners.getOwnertypeid()); stmt.setLong(7, owners.getId()); stmt.execute(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; BaseDao.closeAll(null, stmt, conn); &#125; &#125; /** * 删除业主 * @param owners */ public static void delete(Long id)&#123; java.sql.Connection conn=null; java.sql.PreparedStatement stmt=null; try &#123; conn=BaseDao.getConnection(); stmt=conn.prepareStatement(\"delete from T_OWNERS where id=?\"); stmt.setLong(1, id); stmt.execute(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; BaseDao.closeAll(null, stmt, conn); &#125; &#125;&#125; 14.整库导出和导入.avi整库导出命令: exp system/itcast full=y指定备份文件的名称导出命令: exp system/itcast file=文件名 full=y整库导入命令: imp system/itcast full=y指定备份文件的名称导入命令: imp system/itcast full=y file=water.dmp如果不指定 file 参数，则默认用备份文件 EXPDAT.DMP 进行导入如果指定 file 参数，则按照 file 指定的备份文件进行恢复 15.按用户和表导入导出.avi按用户导出: exp system/itcast owner=wateruser file=wateruser.dmp按用户导入: imp system/itcast file=wateruser.dmp fromuser=wateruser 按表导出：exp wateruser/itcast file=a.dmp tables=t_account,a_area按表导入：imp wateruser/itcast file=a.dmp tables=t_account,a_area","categories":[],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"增强类中的三种方式","slug":"增强类中的三种方式","date":"2018-07-10T15:40:28.000Z","updated":"2018-07-23T05:31:30.410Z","comments":true,"path":"2018/07/10/增强类中的三种方式/","link":"","permalink":"http://yoursite.com/2018/07/10/增强类中的三种方式/","excerpt":"继承: 控制这个类的构造方法(new 一个对象出来) 重新要增强的父类的方法 使用的是子类装饰者模式: 装饰者类和被装饰者类要实现相同的接口 而且装饰者类要有被装饰者类对象引用 使用的装饰者类动态代理: 被代理的对象要实现接口 使用的是代理对象","text":"继承: 控制这个类的构造方法(new 一个对象出来) 重新要增强的父类的方法 使用的是子类装饰者模式: 装饰者类和被装饰者类要实现相同的接口 而且装饰者类要有被装饰者类对象引用 使用的装饰者类动态代理: 被代理的对象要实现接口 使用的是代理对象 动态代理技术就是用来产生一个对象的代理对象的代理对象存在的价值主要用于拦截对真实业务对象的访问代理对象应该具有和目标对象(真实业务对象)相同的方法现在要生成某一个对象的代理对象，这个代理对象通常也要编写一个类来生成,通过Proxy类提供的一个newProxyInstance方法用来创建一个对象的代理对象static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)newProxyInstance方法用来返回一个代理对象，这个方法总共有3个参数ClassLoader loader 用来指明生成代理对象使用哪个类装载器Class&lt;?&gt;[] interfaces 用来指明生成哪个对象的代理对象，通过接口指定InvocationHandler h 用来指明产生的这个代理对象要做什么事情所以我们只需要调用newProxyInstance方法就可以得到某一个对象的代理对象了在java中规定，要想产生一个对象的代理对象，那么==这个对象必须要有一个接口==,所以只有实现了接口的类才可以创建他的代理对象Proxy类负责创建代理对象时，如果指定了handler（处理器），那么不管用户调用代理对象的什么方法，该方法都是调用处理器的invoke方法由于invoke方法被调用需要三个参数：代理对象、方法、方法的参数，因此不管代理对象哪个方法调用处理器的invoke方法，都必须把自己所在的对象、自己（调用invoke方法的方法）、方法的参数传递进来。因此在动态代理技术里，由于不管用户调用代理对象的什么方法，都是调用开发人员编写的处理器的invoke方法（这相当于invoke方法拦截到了代理对象的方法调用） 动态代理和装饰者模式相同点 : 都能增强一个类的方法不同的 : 如果是装饰者我们得自己写一个装饰者类 实现被装饰者的接口 如果是动态代理 我们直接使用Proxy对象 代理对象其实动态代理解决了装饰者模式的最大缺点就是你不用把接口中所有的方法都重新调用一遍不管是装饰者还是动态代理都会有一个新的类产生 装饰者类 Proxy对象 是在原来的被增强的类基础上进行增强 JDK中动态代理: Proxy对象注意：JDK动态代理 (实现接口)Proxy.newProxyInstance(ClassLoader cl,Class[] interfaces,InvocationHandler ih); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ProxyDemo1 &#123; @Test public void demo1()&#123; Waiter waiter = new Waitress(); // waiter.server(); // 使用动态代理:Proxy.newProxyInstance(); /** * ClassLoader :类加载器. * Class[] :被增强的对象实现的所有接口 * InvocationHandler :处理类. */ // 第一个参数: ClassLoader classLoader = waiter.getClass().getClassLoader(); // 第二个参数: Class[] interfaces = waiter.getClass().getInterfaces(); // 第三次参数: Waiter waiter2 = (Waiter)Proxy.newProxyInstance(classLoader, interfaces, new MyInvocationHandler(waiter)); waiter2.server(); // 说明现在调用代理对象的任何方法的时候,InvocationHandler中的invoke都会执行. String s = waiter2.sayHello(\"张凤\"); System.out.println(s); &#125;&#125;class MyInvocationHandler implements InvocationHandler&#123; private Waiter waiter; public MyInvocationHandler(Waiter waiter)&#123; this.waiter = waiter; &#125; @Override /** * 方法的参数: * * proxy:产生的代理对象. * * method:当前正在调用的目标类的方法. * * params:正在执行的方法中的参数. */ public invoke(Object proxy, Method method, Object[] params) throws Throwable &#123; // System.out.println(\"InvocationHandler invoke 执行了...\"); // System.out.println(\"微笑=========\"); // waiter.sayHello(\"张凤\"); // System.out.println(method.getName()); if(\"server\".equals(method.getName()))&#123; System.out.println(\"微笑==========\"); System.out.println(\"白白==========\"); Object obj = method.invoke(waiter, params); return obj; &#125;else&#123; return method.invoke(waiter, params); &#125; &#125;&#125; 案例一：使用动态代理完成通用字符集编码过滤器：动态代理动态增强一个类中的方法实现InvocationHandler接口 1234@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; 通过反射调用目标方法&#125; 案例二：使用动态代理完成通用字符集编码过滤器：代码实现123456789101112131415161718192021222324252627@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; final HttpServletRequest req = (HttpServletRequest) request; // 增强req: HttpServletRequest myReq = (HttpServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 判断执行的方法是否是getParameter: if(\"getParameter\".equals(method.getName()))&#123; // 调用的是getParameter:需要增强这个方法. // 判断请求方式是GET还是POST: String type = req.getMethod(); if(\"get\".equalsIgnoreCase(type))&#123; String value = (String) method.invoke(req, args); value = new String(value.getBytes(\"ISO-8859-1\"),\"UTF-8\"); return value; &#125;else if(\"post\".equalsIgnoreCase(type))&#123; req.setCharacterEncoding(\"UTF-8\"); &#125; &#125; return method.invoke(req, args); &#125; &#125;); chain.doFilter(myReq, response);&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Because I could not stop for Death","slug":"hello-world","date":"2018-03-24T15:30:00.000Z","updated":"2018-07-25T05:00:36.918Z","comments":true,"path":"2018/03/24/hello-world/","link":"","permalink":"http://yoursite.com/2018/03/24/hello-world/","excerpt":"","text":"去造一个草原 需要一株三叶草和一只蜜蜂， 一株三叶草和一只蜜蜂， 还有梦。 如果蜜蜂不多， 单靠梦也行。 123456789101112131415161718192021222324252627282930313233Because I could not stop for Death Emily DickinsonBecause I could not stop for Death- He kindly stopped for me- The Carriage held but just Ourselves- And Immortality.We slowly drove- He knew no hasteAnd I had put awayMy labor and my leisure too,For His Civility- We passed the School, where Children stroveAt Recess- in the Ring- We passed the Fields of Gazing Grain- We passed the Setting Sun- Or rather- He passed us- The Dews drew quivering and chill- For only Gossamer, my Gown- My Tippet- only Tulle- We paused before a House that seemedA Swelling of the Ground- The Roof was scarcely visible- The Cornice- in the Ground- Since then- &apos;tis Centuries- and yetFeels shorter than the DayI first surmised the Horses&apos; Heads Were toward Eternity-","categories":[],"tags":[{"name":"art","slug":"art","permalink":"http://yoursite.com/tags/art/"}]}]}